# Chapter 2 有意義的命名

### 讓名稱代表意圖－使之名符其實

初學者最常犯的錯誤之一，就是忽略命名的重要而隨意命名，花時間給予好的命名就像投資，會在未來為你省下更多的時間。有幾個原則我們要特別注意：

1. 好的命名不需要額外再提供註解。

```text
int d;  // elapsed time in days
```

上述註解完全就是多餘的，我們只要對命名做一些調整，含義就十分清楚了：

```text
int elapsedTimeInDays;
```

2. 好的命名可以大大降低程式的隱含性\(Implicity\)，以下面的程式碼為例：

```text
public List<int[]> getThem() {
    List<int[]> list1 = new ArrayList<>();
    for (int[] x： theList)
        if (x[0] == 4)
            list1.add(x);
    return list1;
}
```

上述的程式碼無法讓人明瞭其意義：

* theList的內容是什麼？
* theList的第一項內容物件\(索引數0\)代表什麼意義？
* 4是什麼意思？
* 回傳的list1又代表什麼？

假設這是一個踩地雷遊戲，而該方法是要回傳標誌旗子的方格。如果改成以下程式碼：

```text
public List<Cell> getFlaggedCells() {
    List<Cell> flaggedCells = new ArrayList<>();
    for (Cell cell: gameBoard)
        if (cell.isFlagged())
            flaggedCells.add(cell);
    return flaggedCells;
}
```

程式碼的複雜度其實沒有任何的改變，但因為降低了隱含性，可讀性就大大的提升了。

### 避免誤導

我們在命名的時候，通常都會有一些個人的習慣，譬如說習慣用List作為群組資料的命名結尾。作者的建議是不要這麼做，除非該變數真的是List。舉例來說，與其用accoutList，不如改為accountGroups，甚至是accounts。畢竟對於程式設計師來說，List多半是具特殊意義的集合，濫用及可能造成誤解。

另外，當複數個模組或程式功能相似時，要謹慎地給予好區別的命名，否則在引用時非常容易造成誤解。舉例而言：AccountControlForDomesticStorage 和 AccountControlForNonDomesticStorage，就很難以簡單清楚的區分。最後，作者也提到字體的相似導致的錯誤也是我們該避免的，譬如數字0和英文字母O等等。

### 使用能唸出來的名稱

在語言學的領域中，單字的存在是要能夠被發音的，如果我們的變數命名是不好發音的話，那會造成我們的程式碼難以溝通和記憶。舉例而言，genymdhms和generationTimestamp，後者在需要討論時明顯較不會造成困擾。

### 使用可被搜尋的名字

單一字母或較簡短的命名非常難在文字中被找到，你可能為了尋找一個命名為s的變數，卻在IDE的幫助下找到成千上萬的搜尋結果。就這點而言，作者認為長命名是勝過短命名的，畢竟重複機率低，也就更容易搜尋，進而更容易維護。作者另外給出一個原則：

* **命名的長度應該與其視野\(Scope\)的大小相對應**

小函式的區域變數命名上或許可以用較短的名稱，但一旦使用範圍一大，為了避免搜尋上的困擾，還是要盡量給予對應的長命名。

### 避免編碼

不要在變數的命名中使用自訂的額外編碼，這非常容易給程式設計師帶來負擔。舉例而言：XXT0\_0500，對於一個新進員工來說，在能夠開始給予產出之前，還必須要先瞭解這樣的編碼具備什麼樣的意義。

現今各大語言的發展都已趨於成熟，而且IDE也具備強大的檢查機制，我們不需要額外再自行定義編碼，或者遵循古老的編碼方式，不但對程式的運行沒有實質的幫助，也徒增理解的困擾。

#### 成員的字首

不需要再用**m\_**作為成員變數的命名開頭，事實上，現在的IDE都具備自動換色或粗體字的區別功能。

#### 介面和實作

命名介面的時候不需要再加上一個多餘的前綴字作為區別，你或許看過抽象工廠介面以 IShapeFactory這種命名，但實際上那個 I 除了阻礙閱讀外並沒有實際用途，我們不需要告訴使用者這是一個介面，與其如此不如在實作的類別上做區分，像是ShapeFactoryImp都會比介面上做文章清楚的多。

### 避免思維的轉換

程式設計師不應該因為你的程式碼的命名，讓讀者需要在腦中再轉換你所要表達的意思。這通常可能是源自於專有領域的慣用代號，譬如 π = 圓周率，但讀者還要再去理解 π 所代表的意思。

### 類別與方法的命名

類別應使用_**名詞**_命名，而方法則應使用_**動詞**_命名。針對方法命名JavaBean提供一套標準：

* 取出器\(accessors\) 應使用get作為字首     e.g. getName\(\)
* 修改器\(mutators\) 應使用set作為字首       e.g. setName\(String name\)
* 判定器\(predicates\) 應使用is作為字首       e.g. isChecked\(\)

此外，當類別中有多個建構子\(多載 Overloading\) 時，請使用含有參數資訊的靜態工廠方法命名：

```text
Complex fulcrumPoint = Complex.FromRealNumber(23.0);
```

建立物件時意圖會明顯比下方程式碼明顯：

```text
Complex fulcrumPoing = new Complex(23.0);
```

### 每個概念使用一種字詞

在程式中做單一行為時，在命名上不要用多種不同的字詞，例如「取回」這個動作在命名上將retrieve、fetch、get 交互使用，這樣只會增加困擾的機率。程式中有DeviceManager、DeviceDriver、DeviceController等等，會讓讀者困惑，究竟這些類別分別負責管理什麼？

### 別說雙關語

遵循著剛剛提到的「**每個概念使用一種字詞**」原則，最常碰到的問題就是走火入魔似的強迫使用同一個字詞，切記要將概念作明確的區分，只要意思上不一樣，那就應該換另一個命名。舉例來說，「增加」這個行為使用add作為命名，那遇到串接行為就不應該用add命名，畢竟我們實際上並沒有增加任何東西，用append會明顯恰當的多。

### 解決方案領域 vs 問題領域命名

程式設計師對於技術領域的名詞通常會有一定程度的瞭解，所以應儘量使用電腦科學領域的術語，如演算法或設計模式的名稱。舉例而言，AccoutFactory這個命名，對於程式設計師來說就具備明顯而獨特的意義。

相反的，萬一要命名的對象沒有「程式設計師熟悉的術語」可供命名的話，那就應該以該問題領域的名稱命名，至少日後再請教專業領域人士時在溝通上不會有太大阻礙。

### 有意義的上下文資訊 \(Context\)

絕大多數的時候，命名需要在有意義的上下文資訊中才能顯示出他的意義。舉例來說，state這個命名，在前後文都是地址的資訊的話代表州，但若是在其他前後文可能就是代表狀態，所以有意義的前後文資訊能幫助理解程式碼的意義。

反之，若是在每個命名之前都加上沒有意義的資訊的話，除了阻礙理解外也沒有其他效果。舉例而言，如果BMW的類別裡每個命名都加上BMW開頭，例如BMWEngine、BMWDoor、BMWWheel等等，這樣對於屬性的意義只會造成理解上的阻礙罷了。

## 我的觀點

就我目前為止的工作經驗來看，每間公司甚至每個專案，都會自己的一套獨特的命名方式或邏輯，這並非不好，但最大的問題在於_**盲從**_。過去使用的命名方式若已經不合時宜，又何必刻意沿用呢？這無疑也是一種技術債的累積。不諱言，就我個人接觸到的專案中也已經見過許多不好的命名，但多數人卻沒有勇氣去更改或者意識到要改動，我想這也是多數擁有運行多年系統的公司都會遇到的維護上的難題。

