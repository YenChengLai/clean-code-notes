# Chaper 1 無瑕的程式碼

### 程式碼\(Code\)將一直存在

儘管有許多人宣稱模型或人工智能將使未來的人們不需要再寫程式碼，但這是不可能的事。作者認為程式碼的確有可能變得更加抽象化或專一化，但需求永遠不會消失，最終將人類抽象的想法具現化為系統的，仍舊是能讓機器瞭解並執行的程式碼。

### 劣質的程式碼

劣質的程式碼的影響遠比我們想像的巨大，甚至能使一間企業倒閉，最糟糕的是劣質的程式碼**非常容易積累**，常常在未來成為系統維護或開發上的阻礙。**LeBlanc's Law** states: "Later equals never" 如果提交程式碼的當下妥協，通常這些劣質的程式碼也不會有得到改善的機會。

### 雜亂程式的代價

雜亂的程式碼是每個工程師的噩夢，當一個系統的程式碼過於髒亂時，會導致程式開發的邊際效益大幅下降。假設每一次的改動都需要先閱讀過大量且毫無章法的程式碼，能從中汲取的有用資訊卻少之又少，工程師只能在一知半解的情況下開發，自然也不用期待有好成果了。

### 最根本的難題

每個程式設計師都知道開發最根本的難題就是**死線**，在死線的壓力驅使下，我們可能會向程式碼的品質妥協，但事實上，爛程式碼永遠都不會幫助我們趕上死線，只會**馬上降低**我們的開發速度，所以隨時注意保持程式碼的乾淨整潔才是最有效提升開發速度的方法。

## 什麼是Clean Code

針對怎樣的程式碼算是最乾淨、最整潔無瑕，作者在書中節錄了多位著名且資深的程式設計師的看法，每一位都有自己的見解，但都有一定程度的相似性，總結來說可分為以下幾點：

* 簡潔易懂，不會掩蓋程式的目的
* 具有擴充性並盡可能降低相依性
* 俐落的抽象概念
* 沒有冗餘重複的部分
* 能通過所有測試

至於作者本身又是如何定義Clean Code呢？接下來的章節會逐步且詳細地闡述。

## 我的觀點

從進入銀行工作到現在，我非常幸運的不需要扛下系統維護的重擔，但或多或少也是參與過許多既有專案的翻新。印象最深刻的就是在翻新某個系統時\(不便具名透露\)，因為既有的程式碼撰寫品質良莠不齊，也沒有具體的文件可以參考，導致團隊在作業上遭遇嚴重的困難，連負責提出需求的單位都無法完整的理解系統所要達成的功能。

到了最後，我還是硬著頭皮在死線的最後完成了公司交辦的任務，不過我自己記得非常清楚，儘管我當時能力和資歷都尚淺，在提交程式碼的當下，我仍然很確定這段程式碼也會成為未來技術債的一部分\(事實上也的確如此\)。

這段經歷是我自開始寫程式以來最難忘的失敗，也是促成我開始理解與要求達到clean code的起始，本書的第一個章節帶給我的體悟，相信也在諸多程式設計師心中引起深刻的共鳴，期望我們都能透過本書成長，達到撰寫clean code的境界。

